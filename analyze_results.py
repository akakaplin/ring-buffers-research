import matplotlib
# matplotlib.use("TkAgg") <-- What I use on Ubuntu

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import hashlib
import json
import os
import math

import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", message="No artists with labels found to put in legend")


plt.style.use('dark_background')

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    UNDERLINE = '\033[4m'


# =------------------------------------------= #

def get_color(ring_name):
    return f"#{hashlib.md5(ring_name.encode()).hexdigest()[:6]}"

def get_df(dir):
    data = []
    for file in os.listdir(dir):
        with open(os.path.join(dir, file), "r") as f:
            data.extend([json.loads(line) for line in f])
    return pd.DataFrame(data)


# =------------------------------------------= #
# - As a Rust main I refuse to code in python more than I have to - plots generated by Claude (ty Anthropic)

def plot_stacked_metrics_by_implementation(df, x_var, y_vars, control_var):
    df = df.drop(columns=["payload_type", "payload_stash_gen_on_fly", "consumer_id"])
    implementations = sorted(df['ring_name'].unique())
    control_values = sorted(df[control_var].unique())
    cmap = plt.colormaps['viridis']

    for ring_name in implementations:
        fig, axes = plt.subplots(len(y_vars), 1, figsize=(10, 5 * len(y_vars)))
        if len(y_vars) == 1:
            axes = [axes]
            
        fig.suptitle(f"{ring_name}")
        
        ring_name_df = df[df['ring_name'] == ring_name]
        for ax_idx, y_var in enumerate(y_vars):
            ax = axes[ax_idx]

            for i, ctrl_val in enumerate(control_values):
                filtered_df = ring_name_df[ring_name_df[control_var] == ctrl_val]
                group_df = filtered_df.groupby(x_var)[y_var].mean().reset_index()
                
                if not group_df.empty:
                    group_df = group_df.sort_values(by=x_var)
                    ax.plot(group_df[x_var], group_df[y_var], 'o-', label=f"{control_var}={ctrl_val}", color=cmap(i/len(control_values)))
            
            ax.set_xlabel(x_var.replace('_', ' ').title())
            ax.set_ylabel(y_var.replace('_', ' ').title())
            ax.legend()
            ax.grid(alpha=0.3)
        plt.tight_layout()
    plt.tight_layout()

def plot_heatmap_by_implementation(df, x_var, y_var, value_var):
    df = df.drop(columns=["payload_type", "payload_stash_gen_on_fly", "consumer_id"])
    implementations = sorted(df['ring_name'].unique())
    
    fig, axes = plt.subplots(2, math.ceil(len(implementations)/2), figsize=(15, 12))
    fig.suptitle(f"{value_var.replace('_', ' ').title()} by {x_var.replace('_', ' ').title()} and {y_var.replace('_', ' ').title()}")
    
    axes = axes.flatten()
    
    for i, ring_name in enumerate(implementations):
        ring_name_df = df[df['ring_name'] == ring_name]
        
        pivot_df = ring_name_df.pivot_table(index=y_var, columns=x_var, values=value_var, aggfunc='mean')
        
        vmin = df[value_var].min()
        vmax = df[value_var].max()
        
        sns.heatmap(pivot_df, cmap="viridis", ax=axes[i], cbar_kws={'label': value_var.replace('_', ' ').title()}, vmin=vmin, vmax=vmax)
        
        axes[i].set_title(f"{ring_name}")
        axes[i].set_ylabel(y_var.replace('_', ' ').title())
        axes[i].set_xlabel(x_var.replace('_', ' ').title())
    
    for j in range(len(implementations), len(axes)):
        axes[j].axis('off')
    
    plt.tight_layout()


def plot_implementation_comparison(channel_type, df, x_var, y_vars, control_var=None, control_val=None):
    df = df.drop(columns=["payload_type", "payload_stash_gen_on_fly", "consumer_id"])
    implementations = sorted(df['ring_name'].unique())
    
    if not isinstance(y_vars, list):
        y_vars = [y_vars]
    
    fig, axes = plt.subplots(len(y_vars), 1, figsize=(12, 5 * len(y_vars)))
    if len(y_vars) == 1:
        axes = [axes]
    
    fig.suptitle(f"{channel_type} Ring Impl Comparison")
    
    filtered_df = df
    subtitle = ""
    if control_var and control_val is not None:
        filtered_df = df[df[control_var] == control_val]
        subtitle = f" ({control_var}={control_val})"
    
    for i, y_var in enumerate(y_vars):
        ax = axes[i]
        for ring_name in implementations:
            ring_df = filtered_df[filtered_df['ring_name'] == ring_name]
            if not ring_df.empty:
                grouped = ring_df.groupby(x_var)[y_var].mean().reset_index()
                grouped = grouped.sort_values(by=x_var)
                ax.plot(grouped[x_var], grouped[y_var], 'o-', label=ring_name, color=get_color(ring_name), linewidth=2)
        
        ax.set_xlabel(x_var.replace('_', ' ').title())
        ax.set_ylabel(y_var.replace('_', ' ').title())
        ax.set_title(f"{y_var.replace('_', ' ').title()} by {x_var.replace('_', ' ').title()}{subtitle}")
        ax.legend()
        ax.grid(alpha=0.3)
    
    plt.tight_layout()

def plot_bar_comparison(channel_type, df, x_var, y_var, control_vars=None):
    df = df.drop(columns=["payload_type", "payload_stash_gen_on_fly", "consumer_id"])
    
    filtered_df = df
    subtitle = ""
    if control_vars:
        for var, val in control_vars.items():
            filtered_df = filtered_df[filtered_df[var] == val]
            subtitle += f"{var}={val}, "
        subtitle = subtitle[:-2]
    
    fig, ax = plt.subplots(figsize=(10, 6))
    fig.suptitle(f"{channel_type} Implementation Comparison - {y_var.replace('_', ' ').title()}")
    
    if x_var == 'ring_name':
        grouped = filtered_df.groupby('ring_name')[y_var].mean().reset_index()
        ax.bar(grouped['ring_name'], grouped[y_var], color=[get_color(name) for name in grouped['ring_name']])
        ax.set_xlabel('Ring Name')
    else:
        implementations = sorted(filtered_df['ring_name'].unique())
        grouped = filtered_df.groupby([x_var, 'ring_name'])[y_var].mean().reset_index()
        
        x_categories = sorted(grouped[x_var].unique())
        width = 0.8 / len(implementations)
        
        for i, ring_name in enumerate(implementations):
            impl_data = grouped[grouped['ring_name'] == ring_name]
            positions = [j + (i - len(implementations)/2 + 0.5) * width for j in range(len(x_categories))]
            ax.bar(positions, impl_data[y_var], width=width, label=ring_name, color=get_color(ring_name))
        
        ax.set_xticks(range(len(x_categories)))
        ax.set_xticklabels(x_categories)
        ax.set_xlabel(x_var.replace('_', ' ').title())
        ax.legend()
    
    ax.set_ylabel(y_var.replace('_', ' ').title())
    if subtitle:
        ax.set_title(f"Configuration: {subtitle}")
    ax.grid(alpha=0.3, axis='y')
    plt.tight_layout()

# =------------------------------------------= #

def main():

    # =-= Channel Types =-= #
    analyze_mpmc = True
    analyze_mpsc = True
    analyze_spmc = True
    analyze_spsc = True

    # =-= Data =-= #
    payload_copyable = True # CopyablePayload (True) or HeapPayload (False)
    dependent_variables = ["bytes_throughput_per_ms", "throughput_msgs_per_us"]

    plot_heatmap_msg_thoughput = True
    plot_heatmap_bytes_throughput = True
    plot_indiv_ring_metrics = False
    plot_indiv_analysis_by_thread_count = False # MPMC, MPSC, & SPMC only
    plot_bar_comparison_by_thread_count_config = False # MPMC, MPSC, & SPMC only
    plot_analysis_controlled_by_ring_size = False
    plot_analysis_controlled_by_payload_size = False
    plot_bar_comparison_by_config = False
    
    # =-= Control Variables =-= #
    ring_size_control = 1024
    payload_size_control = 1024
    bar_comparison_payload_ring_config = {"payload_size": 256, "ring_size": 1024}
    bar_comparison_thread_count_config = {"consumer_threads": 2, "producer_threads": 3}

    # =---------------------------------------------= #
    
    if analyze_mpmc:
        mpmc_df = get_df("results/MPMC")
        mpmc_df = mpmc_df[mpmc_df['copyable_payload'] == payload_copyable]
        if not mpmc_df.empty:
            if plot_indiv_ring_metrics:
                plot_stacked_metrics_by_implementation(mpmc_df, "payload_size", dependent_variables, "ring_size")
            if plot_heatmap_bytes_throughput:
                plot_heatmap_by_implementation(mpmc_df, "payload_size", "ring_size", "bytes_throughput_per_ms")
            if plot_heatmap_msg_thoughput: 
                plot_heatmap_by_implementation(mpmc_df, "payload_size", "ring_size", "throughput_msgs_per_us")
            if plot_indiv_analysis_by_thread_count:
                plot_stacked_metrics_by_implementation(mpmc_df, "consumer_threads", dependent_variables, "producer_threads")
            if plot_bar_comparison_by_thread_count_config:
                plot_bar_comparison("MPMC", mpmc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_thread_count_config)
            if plot_analysis_controlled_by_ring_size:
                plot_implementation_comparison("MPMC", mpmc_df, "payload_size", dependent_variables, "ring_size", ring_size_control)
            if plot_analysis_controlled_by_payload_size:
                plot_implementation_comparison("MPMC", mpmc_df, "ring_size", dependent_variables, "payload_size", payload_size_control)
            if plot_bar_comparison_by_config:
                plot_bar_comparison("MPMC", mpmc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_payload_ring_config)
        
    if analyze_mpsc:
        mpsc_df = get_df("results/MPSC")
        mpsc_df = mpsc_df[mpsc_df['copyable_payload'] == payload_copyable]
        if not mpsc_df.empty:
            if plot_indiv_ring_metrics:
                plot_stacked_metrics_by_implementation(mpsc_df, "payload_size", dependent_variables, "ring_size")
            if plot_heatmap_bytes_throughput:
                plot_heatmap_by_implementation(mpsc_df, "payload_size", "ring_size", "bytes_throughput_per_ms")
            if plot_heatmap_msg_thoughput:
                plot_heatmap_by_implementation(mpsc_df, "payload_size", "ring_size", "throughput_msgs_per_us")
            if plot_indiv_analysis_by_thread_count:
                plot_stacked_metrics_by_implementation(mpsc_df, "consumer_threads", dependent_variables, "producer_threads")
            if plot_bar_comparison_by_thread_count_config:
                plot_bar_comparison("MPSC", mpsc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_thread_count_config)
            if plot_analysis_controlled_by_ring_size:
                plot_implementation_comparison("MPSC", mpsc_df, "payload_size", dependent_variables, "ring_size", ring_size_control)
            if plot_analysis_controlled_by_payload_size:
                plot_implementation_comparison("MPSC", mpsc_df, "ring_size", dependent_variables, "payload_size", payload_size_control)
            if plot_bar_comparison_by_config:
                plot_bar_comparison("MPSC", mpsc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_payload_ring_config)

    if analyze_spmc:
        spmc_df = get_df("results/SPMC")
        spmc_df = spmc_df[spmc_df['copyable_payload'] == payload_copyable]
        if not spmc_df.empty:
            if plot_indiv_ring_metrics:
                plot_stacked_metrics_by_implementation(spmc_df, "payload_size", dependent_variables, "ring_size")
            if plot_heatmap_bytes_throughput:
                plot_heatmap_by_implementation(spmc_df, "payload_size", "ring_size", "bytes_throughput_per_ms")
            if plot_heatmap_msg_thoughput:
                plot_heatmap_by_implementation(spmc_df, "payload_size", "ring_size", "throughput_msgs_per_us")
            if plot_indiv_analysis_by_thread_count:
                plot_stacked_metrics_by_implementation(spmc_df, "consumer_threads", dependent_variables, "producer_threads")
            if plot_bar_comparison_by_thread_count_config:
                plot_bar_comparison("SPMC", spmc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_thread_count_config)
            if plot_analysis_controlled_by_ring_size:
                plot_implementation_comparison("SPMC", spmc_df, "payload_size", dependent_variables, "ring_size", ring_size_control)
            if plot_analysis_controlled_by_payload_size:
                plot_implementation_comparison("SPMC", spmc_df, "ring_size", dependent_variables, "payload_size", payload_size_control)
            if plot_bar_comparison_by_config:
                plot_bar_comparison("SPMC", spmc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_payload_ring_config)

    if analyze_spsc:
        spsc_df = get_df("results/SPSC")
        spsc_df = spsc_df[spsc_df['copyable_payload'] == payload_copyable]
        if not spsc_df.empty:
            if plot_indiv_ring_metrics:
                plot_stacked_metrics_by_implementation(spsc_df, "payload_size", dependent_variables, "ring_size")
            if plot_heatmap_bytes_throughput:
                plot_heatmap_by_implementation(spsc_df, "payload_size", "ring_size", "bytes_throughput_per_ms")
            if plot_heatmap_msg_thoughput:
                plot_heatmap_by_implementation(spsc_df, "payload_size", "ring_size", "throughput_msgs_per_us")
            if plot_analysis_controlled_by_ring_size:
                plot_implementation_comparison("SPSC", spsc_df, "payload_size", dependent_variables, "ring_size", ring_size_control)
            if plot_analysis_controlled_by_payload_size:
                plot_implementation_comparison("SPSC", spsc_df, "ring_size", dependent_variables, "payload_size", payload_size_control)
            if plot_bar_comparison_by_config:
                plot_bar_comparison("SPSC", spsc_df, "ring_name", "bytes_throughput_per_ms", bar_comparison_payload_ring_config)

    plt.show()


if __name__ == "__main__":
    main()